"""
Arbor AI – process monitoring and adjustment tool
=================================================

This Streamlit application provides a prototype user interface for
operators at Arbor to log process data, visualise trends, receive
AI‑based suggestions for parameter adjustments and perform basic
optical character recognition (OCR) on uploaded images of manual
measurements.  It demonstrates how a web‑based tool can help
reduce waste and energy consumption while improving product
quality and operator training.

The app is designed to be run with Streamlit (``streamlit run
arbor_ai_app.py``) and uses pandas, scikit‑learn and Plotly for
data handling and visualisation.  OCR functionality is provided via
EasyOCR, although you can replace it with Tesseract (pytesseract)
if preferred.  See the docstring and comments throughout for
guidance on how the different components work.

Note: this file is provided as a starting point; you may need
additional packages such as ``streamlit``, ``easyocr`` and
``pytesseract`` installed on your system.  Because the execution
environment of this project does not include these packages,
you should run the app locally after installing the dependencies
via ``pip install streamlit easyocr scikit-learn pandas plotly`` and
ensuring you have a working OCR backend.  When using Tesseract,
remember to install the Tesseract engine and set the correct
executable path for your platform.

Created: July 2025
"""

import datetime
import io
from typing import List, Tuple

import numpy as np
import pandas as pd
import plotly.express as px

try:
    import streamlit as st  # type: ignore
except ImportError:
    raise ImportError(
        "Streamlit is required to run this application. Install it via ``pip install streamlit``."
    )

# Optional OCR imports.  We wrap them in a try/except so that the
# application doesn’t crash if OCR libraries are unavailable.  If
# neither library is installed, the OCR feature will be disabled.
try:
    import easyocr  # type: ignore
except ImportError:
    easyocr = None  # type: ignore

try:
    import pytesseract  # type: ignore
    from PIL import Image  # type: ignore
except ImportError:
    pytesseract = None  # type: ignore

from sklearn.linear_model import LinearRegression  # type: ignore


def initialise_data() -> pd.DataFrame:
    """Initialise the session‑state DataFrame for logging.

    Columns are timestamp, temperature, airflow, bunker_level,
    humidity, manual_feed and ai_feed.  Manual feed represents
    operator‑chosen feed rates; ai_feed is the suggested feed rate
    generated by our simple model.

    Returns
    -------
    pd.DataFrame
        A DataFrame with the appropriate columns.
    """
    return pd.DataFrame(
        columns=[
            "timestamp",
            "temperature",
            "airflow",
            "bunker_level",
            "humidity",
            "manual_feed",
            "ai_feed",
        ]
    )


def simulate_sensor_reading() -> Tuple[float, float, float, float, float]:
    """Generate a simulated sensor reading.

    This helper function produces random values within plausible
    ranges for demonstration purposes.  In a real production
    environment you would replace this with actual sensor
    integration (e.g. reading from PLCs or IoT devices).

    Returns
    -------
    Tuple[float, float, float, float, float]
        Random values for temperature (°C), airflow (m³/h), bunker
        level (% full), humidity (%) and manual feed (kg/h).
    """
    temperature = np.random.uniform(60, 90)  # exit temperature in °C
    airflow = np.random.uniform(1000, 2000)  # fresh air supply in m³/h
    bunker = np.random.uniform(0, 100)  # level in percent
    humidity = np.random.uniform(5, 15)  # relative humidity in %
    manual_feed = np.random.uniform(150, 250)  # feed rate in kg/h
    return temperature, airflow, bunker, humidity, manual_feed


def update_ai_model(data: pd.DataFrame) -> LinearRegression:
    """Train a simple linear regression model on existing data.

    The model attempts to learn a relationship between process
    variables (temperature, airflow, bunker_level, humidity) and
    manual_feed to emulate operator behaviour.  We then use this
    model to generate an AI recommendation for the feed rate.  In
    a production implementation you would likely employ more
    sophisticated models (random forests, gradient boosting or
    reinforcement learning) and incorporate quality metrics as
    targets.

    Parameters
    ----------
    data : pd.DataFrame
        Data logged so far.

    Returns
    -------
    LinearRegression
        A fitted scikit‑learn linear regression model.
    """
    model = LinearRegression()
    # Ensure we have enough data points.  Require at least 5 rows.
    if len(data) < 5:
        # Fit model with dummy data to avoid errors.  The model
        # coefficients will be zero and it will output the mean
        # manual_feed as the intercept.
        X_dummy = np.random.rand(5, 4)
        y_dummy = np.random.rand(5)
        model.fit(X_dummy, y_dummy)
        return model

    X = data[["temperature", "airflow", "bunker_level", "humidity"]].values
    y = data["manual_feed"].values
    model.fit(X, y)
    return model


def suggest_ai_feed(model: LinearRegression, sample: np.ndarray) -> float:
    """Generate a feed rate suggestion using the trained model.

    Parameters
    ----------
    model : LinearRegression
        A fitted linear regression model.
    sample : np.ndarray
        A one‑dimensional array with the four process inputs in
        order: temperature, airflow, bunker_level, humidity.

    Returns
    -------
    float
        The model’s predicted feed rate (kg/h).
    """
    return float(model.predict(sample.reshape(1, -1))[0])


def perform_easyocr(img_bytes: bytes) -> str:
    """Perform OCR on image bytes using EasyOCR.

    Parameters
    ----------
    img_bytes : bytes
        The raw image data from a file upload.

    Returns
    -------
    str
        The concatenated text extracted from the image.  If
        EasyOCR is not available, returns an informative message.
    """
    if easyocr is None:
        return "EasyOCR is not installed. Install it via `pip install easyocr` to enable this feature."
    # Load the image using PIL
    image = Image.open(io.BytesIO(img_bytes))  # type: ignore[name-defined]
    reader = easyocr.Reader(["en"])  # specify language
    result = reader.readtext(np.array(image), detail=0)
    return "\n".join(result)


def perform_pytesseract(img_bytes: bytes) -> str:
    """Perform OCR on image bytes using Tesseract via pytesseract.

    Parameters
    ----------
    img_bytes : bytes
        The raw image data from a file upload.

    Returns
    -------
    str
        The extracted text.  If pytesseract is unavailable or
        Tesseract is not installed, returns an informative message.
    """
    if pytesseract is None:
        return "pytesseract is not installed. Install it via `pip install pytesseract` and ensure the Tesseract engine is available."
    image = Image.open(io.BytesIO(img_bytes))
    try:
        text = pytesseract.image_to_string(image)
    except Exception as e:
        text = f"Error running Tesseract OCR: {e}"
    return text


def main() -> None:
    """Main entry point for the Streamlit app."""
    st.set_page_config(page_title="Arbor AI App", layout="wide")
    st.title("Arbor AI: Prosessovervåkning og justering")

    # Explanatory information for users
    st.markdown(
        """
        Denne prototypen viser hvordan en AI‑drevet applikasjon kan
        støtte operatører hos Arbor i å loggføre prosessdata,
        visualisere trender, motta justeringsforslag og redusere
        energiforbruk og svinn.  Ved å analysere historiske data
        kan modellen foreslå optimale innstillinger og gi varsler
        om avvik før de påvirker produksjonen.  Forskning viser at
        prediktivt vedlikehold kan redusere uplanlagt nedetid med
        opptil **50 %** og øke effektiviteten ved å sørge for at
        vedlikehold utføres på riktig tidspunkt【845464806870182†L100-L128】.
        Lignende AI‑tilnærminger til energistyring kan redusere
        energikostnader med **omtrent 20 %** ved å forutsi
        energibehov og justere driftsparametere i sanntid【171132782165023†L150-L190】.
        """
    )

    # Initialise session state
    if "data" not in st.session_state:
        st.session_state["data"] = initialise_data()

    # Sidebar for logging controls
    st.sidebar.header("Loggføring")
    if st.sidebar.button("Simuler sensormåling"):
        # Generate a new random reading and append
        temp, air, bunk, hum, m_feed = simulate_sensor_reading()
        new_record = {
            "timestamp": datetime.datetime.now(),
            "temperature": temp,
            "airflow": air,
            "bunker_level": bunk,
            "humidity": hum,
            "manual_feed": m_feed,
            "ai_feed": np.nan,
        }
        st.session_state["data"] = st.session_state["data"].append(
            new_record, ignore_index=True
        )

    st.sidebar.subheader("Manuell registrering")
    manual_temp = st.sidebar.number_input("Utløpstemperatur (°C)", min_value=0.0, max_value=120.0, value=75.0)
    manual_air = st.sidebar.number_input("Friskluftmengde (m³/h)", min_value=0.0, max_value=5000.0, value=1500.0)
    manual_bunker = st.sidebar.number_input("Bunkernivå (%)", min_value=0.0, max_value=100.0, value=50.0)
    manual_humidity = st.sidebar.number_input("Fuktighet (%)", min_value=0.0, max_value=100.0, value=10.0)
    manual_feed = st.sidebar.number_input("Matingshastighet (kg/h)", min_value=0.0, max_value=1000.0, value=200.0)

    if st.sidebar.button("Legg til manuell logg"):
        new_manual = {
            "timestamp": datetime.datetime.now(),
            "temperature": manual_temp,
            "airflow": manual_air,
            "bunker_level": manual_bunker,
            "humidity": manual_humidity,
            "manual_feed": manual_feed,
            "ai_feed": np.nan,
        }
        st.session_state["data"] = st.session_state["data"].append(
            new_manual, ignore_index=True
        )

    # Display data
    data = st.session_state["data"]
    if not data.empty:
        st.subheader("Historiske data")
        st.dataframe(data)

        # Train model and update AI suggestions
        model = update_ai_model(data)
        # Compute suggestions for any rows without ai_feed
        if not data.empty:
            rows_to_update = data["ai_feed"].isna()
            for idx in data[rows_to_update].index:
                sample = data.loc[idx, ["temperature", "airflow", "bunker_level", "humidity"]].values
                ai_prediction = suggest_ai_feed(model, np.array(sample, dtype=float))
                st.session_state["data"].at[idx, "ai_feed"] = ai_prediction

        # Visualisation
        st.subheader("Prosessvariabler over tid")
        fig = px.line(
            st.session_state["data"],
            x="timestamp",
            y=["temperature", "airflow", "bunker_level", "humidity"],
            labels={"value": "Måleverdi", "timestamp": "Tid", "variable": "Parameter"},
            title="Historiske prosessvariabler",
        )
        st.plotly_chart(fig, use_container_width=True)

        # Compare manual vs AI feed rates
        st.subheader("Sammenligning av manuell vs AI‑styrt mating")
        comp_fig = px.line(
            st.session_state["data"],
            x="timestamp",
            y=["manual_feed", "ai_feed"],
            labels={"value": "Mating (kg/h)", "timestamp": "Tid", "variable": "Type"},
            title="Manuell mating vs AI‑forslag",
        )
        st.plotly_chart(comp_fig, use_container_width=True)

        # Simple alerting system: highlight deviations > 15 % between manual and AI
        deviations = np.abs(data["manual_feed"] - data["ai_feed"]) / data["manual_feed"]
        high_dev = deviations > 0.15
        if any(high_dev):
            st.warning(
                f"Det er {high_dev.sum()} logg(r) med mer enn 15 % avvik mellom manuell og AI‑mating."
            )

    # OCR section
    st.subheader("Bildeopplasting og avlesning")
    st.write(
        "Last opp et bilde av en manuell måling (f.eks. foto av et fuktighetsinstrument) for å lese av verdien automatisk."
    )
    uploaded_image = st.file_uploader("Last opp bilde", type=["png", "jpg", "jpeg"])
    ocr_engine = st.selectbox(
        "Velg OCR‑motor", options=["Ingen", "EasyOCR", "Tesseract"]
    )
    if uploaded_image is not None and ocr_engine != "Ingen":
        img_bytes = uploaded_image.read()
        with st.spinner("Kjører OCR..."):
            if ocr_engine == "EasyOCR":
                text_out = perform_easyocr(img_bytes)
            else:
                text_out = perform_pytesseract(img_bytes)
        st.text_area("Ekstrahert tekst", value=text_out, height=200)

    # Predictive maintenance (basic example)
    st.subheader("Prediktivt vedlikehold (eksempel)")
    st.write(
        "Denne seksjonen illustrerer hvordan en enkel varslingsmekanisme kan vise at et produksjonsledd nærmer seg behov for vedlikehold. \n"
        "Vi beregner her et glidende gjennomsnitt av bunkernivået og markerer hvis trenden faller under 20 %."
    )
    if not data.empty:
        df = st.session_state["data"].copy()
        df["bunker_sma"] = df["bunker_level"].rolling(window=5, min_periods=1).mean()
        fig_bunker = px.line(
            df,
            x="timestamp",
            y=["bunker_level", "bunker_sma"],
            labels={"value": "Bunkernivå (%)", "timestamp": "Tid", "variable": "Serie"},
            title="Bunkernivå og glidende gjennomsnitt",
        )
        st.plotly_chart(fig_bunker, use_container_width=True)
        # Check if sma falls below threshold
        if any(df["bunker_sma"] < 20):
            st.error(
                "Glidende gjennomsnitt av bunkernivå er under 20 %. Planlegg vedlikehold snart!"
            )


if __name__ == "__main__":
    main()